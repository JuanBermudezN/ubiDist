const { generateMnemonic, mnemonicToEntropy }  = require("ethereum-cryptography/bip39");
const { HDKey } = require("ethereum-cryptography/hdkey");
const { wordlist } = require("ethereum-cryptography/bip39/wordlists/english");
const { secp256k1 } = require("ethereum-cryptography/secp256k1");
const { keccak256 } = require("ethereum-cryptography/keccak");
const { bytesToHex } = require("ethereum-cryptography/utils");
const { writeFileSync } = require("fs");

// Following https://chain.link/tutorials/how-to-build-a-crypto-wallet tutorial


// This function generates the seed phrase, a 256 bits-long entropy will produce a mnemonic of 24 words
function _generateMnemonic() {
  const strength = 256; 
  const mnemonic = generateMnemonic(wordlist, strength);
  const entropy = mnemonicToEntropy(mnemonic, wordlist);
  return { mnemonic, entropy };
}

// BIP-32 is a specification for creating Hierarchical Deterministic (HD) wallets,
// where a single key can be used to generate an entire tree of key pairs. This single
// key serves as the root of the tree and it will always be generated by the exact same
// combination of words, also known as mnemonic or seed phrase.
function _getHdRootKey(_mnemonic) {
  return HDKey.fromMasterSeed(_mnemonic);
}

// Ethereum and Bitcoin use the secp256k1 elliptic curve for cryptographic computations.
// Each accountâ€™s public key is derived from a corresponding private key using the
// Elliptic Curve Digital Signature Algorithm or ECDSA for short. By applying the
// ECDSA to the private key, we get a 64-byte integer, which is two 32-byte integers
// that represent X and Y of a point on the secp256k1 elliptic curve, concatenated
// together. The math behind this algorithm allows software to easily calculate the
// public key of a given private key, while the reverse process is impossible.
function _generatePrivateKey(_hdRootKey, _accountIndex) {
    return _hdRootKey.deriveChild(_accountIndex).privateKey;
  }

// To calculate an address from the public key, we need to apply the Keccak-256 hashing
// algorithm to the public key and take the last (least significant) 20 bytes of the result.
function _getPublicKey(_privateKey) {
    return secp256k1.getPublicKey(_privateKey);
  }

// To calculate an address from the public key, we need to apply the Keccak-256 hashing
// algorithm to the public key and take the last (least significant) 20 bytes of the result.
  function _getEthAddress(_publicKey) {
    return keccak256(_publicKey).slice(-20);
  }
  
  function generateWallet(accountIndex = 0) {
    const { mnemonic, entropy } = _generateMnemonic();
    const hdRootKey = _getHdRootKey(entropy);
    const privateKey = _generatePrivateKey(hdRootKey, accountIndex);
    const publicKey = _getPublicKey(privateKey);
    const address = _getEthAddress(publicKey);
    return { mnemonic, publicKey: bytesToHex(publicKey), address: bytesToHex(address) };
  }

  function storeWalletFile() {
    const wallet = generateWalletFirstAccount();
    writeFileSync("wallet.json", JSON.stringify(wallet));
  }